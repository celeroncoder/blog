<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>REST with Rust | celeronCoder's Blog</title><meta name=keywords content="rest_api,guide,rust"><meta name=description content="Calling Rest APIs with Rust"><meta name=author content><link rel=canonical href=https://celeroncoder.github.io/blog/posts/rest-with-rust/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raw.githubusercontent.com/gist/celeronCoder/bf4dbcc95f3919e2b374dc60b0c01391/raw/efe5fe3f1cfad1dd862fdbefd760f1815c6d2a1a/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://celeroncoder.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://celeroncoder.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://celeroncoder.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://celeroncoder.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="REST with Rust"><meta property="og:description" content="Calling Rest APIs with Rust"><meta property="og:type" content="article"><meta property="og:url" content="https://celeroncoder.github.io/blog/posts/rest-with-rust/"><meta property="og:image" content="https://celeroncoder.github.io/blog/uploads/rest-with-rust.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-04T18:30:00+00:00"><meta property="article:modified_time" content="2022-09-04T18:30:00+00:00"><meta property="og:site_name" content="celeronCoder"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://celeroncoder.github.io/blog/uploads/rest-with-rust.webp"><meta name=twitter:title content="REST with Rust"><meta name=twitter:description content="Calling Rest APIs with Rust"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://celeroncoder.github.io/blog/posts/"},{"@type":"ListItem","position":3,"name":"REST with Rust","item":"https://celeroncoder.github.io/blog/posts/rest-with-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"REST with Rust","name":"REST with Rust","description":"Calling Rest APIs with Rust","keywords":["rest_api","guide","rust"],"articleBody":"Calling REST APIs with rust may seem like a daunting task at first because of the steep and long learning curve of rust as a programming language.\nWe know that contacting with REST APIs is something that we come across creating almost any other app that comes to mind.\nWe’ll make use of the reqwest library to make our request that is essentially a higher level implementation of the default HTTP client.\n# Cargo.toml reqwest = { version = \"0.11\", features = [\"json\"] } tokio = { version = \"1\", features = [\"full\"] } dotenv = \"0.15.0\" # optional serde = {version = \"1.0.144\", features = [\"derive\"]} We import the following libraries to make this work\nLibrary Purpose reqwest to make our requests tokio to make async requests and other async stuff. serde to deserialize the json response into a rust struct Making Basic GET Requests #[tokio::main] async fn main() -\u003e Result\u003c(), Box\u003e { let resp = reqwest::get(\"\").await?; let resp_json = resp.json::","wordCount":"653","inLanguage":"en","image":"https://celeroncoder.github.io/blog/uploads/rest-with-rust.webp","datePublished":"2022-09-04T18:30:00Z","dateModified":"2022-09-04T18:30:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://celeroncoder.github.io/blog/posts/rest-with-rust/"},"publisher":{"@type":"Organization","name":"celeronCoder's Blog","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/gist/celeronCoder/bf4dbcc95f3919e2b374dc60b0c01391/raw/efe5fe3f1cfad1dd862fdbefd760f1815c6d2a1a/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://celeroncoder.github.io/blog accesskey=h title="celeronCoder's Blog (Alt + H)">celeronCoder's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://celeroncoder.github.io/blog>Home</a>&nbsp;»&nbsp;<a href=https://celeroncoder.github.io/blog/posts/>Posts</a></div><h1 class=post-title>REST with Rust</h1><div class=post-description>Calling Rest APIs with Rust</div><div class=post-meta><span title='2022-09-04 18:30:00 +0000 UTC'>September 4, 4030</span>&nbsp;·&nbsp;4 min</div></header><figure class=entry-cover><img loading=lazy src=https://celeroncoder.github.io/blog/uploads/rest-with-rust.webp alt="Rest with Rust Cover"></figure><div class=post-content><p>Calling REST APIs with rust may seem like a daunting task at first because of the steep and long learning curve of rust as a programming language.</p><p>We know that contacting with REST APIs is something that we come across creating almost any other app that comes to mind.</p><p>We’ll make use of the <code>reqwest</code> library to make our request that is essentially a higher level implementation of the default HTTP client.</p><pre><code># Cargo.toml
reqwest = { version = &quot;0.11&quot;, features = [&quot;json&quot;] }
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
dotenv = &quot;0.15.0&quot; # optional
serde = {version = &quot;1.0.144&quot;, features = [&quot;derive&quot;]}
</code></pre><p>We import the following libraries to make this work</p><table><thead><tr><th>Library</th><th>Purpose</th></tr></thead><tbody><tr><td>reqwest</td><td>to make our requests</td></tr><tr><td>tokio</td><td>to make async requests and other async stuff.</td></tr><tr><td>serde</td><td>to deserialize the json response into a rust struct</td></tr></tbody></table><h3 id=making-basic-get-requests><strong>Making Basic GET Requests</strong><a hidden class=anchor aria-hidden=true href=#making-basic-get-requests>#</a></h3><pre><code>#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
	let resp = reqwest::get(&quot;&lt;url&gt;&quot;).await?;
	let resp_json = resp.json::&lt;HashMap&lt;String, String&gt;&gt;().await?;
	
	println!(&quot;{:#?}&quot;, resp_json);

	Ok(());
}
</code></pre><p>Here we do the following key things:</p><ul><li>We add the <code>tokio::main</code> attribute to our main function to use await within our function.</li><li>We change the return type of the main function from unit type - <code>()</code> to a <code>Result&lt;(), Box&lt;dyn std::error::Error>></code> to catch errors from the request if any.</li><li>Then we make the request using the <code>get</code> function and await on that, and also we use the <code>turbofish</code> operator to only get the return type of the <code>future</code><ul><li>More info on why we are using this operator, <a href=https://rust-lang.github.io/async-book/07_workarounds/02_err_in_async_blocks.html>here</a>.</li></ul></li><li>Then we deserialize the JSON response to a <code>HashMap&lt;String, String></code> for convenience and await on that.</li></ul><h3 id=adding-headers-to-our-request>Adding headers to our request<a hidden class=anchor aria-hidden=true href=#adding-headers-to-our-request>#</a></h3><p>To add headers to our request, we first make a request client and use that to add headers to our application.</p><pre><code>use reqwest::header::HeaderMap;

#[tokio::main]
async fn main() {
	...
	let client = reqwest::Client::new();
	let mut headers = HeaderMap::new();
	headers.insert(&quot;content-type&quot;, &quot;application/json&quot;.parse().unwrap());


use reqwest::header::HeaderMap;

#[tokio::main]
async fn main() {
	...
	let client = reqwest::Client::new();
	let mut headers = HeaderMap::new();
	headers.insert(&quot;content-type&quot;, &quot;application/json&quot;.parse().unwrap());
	headers.insert(&quot;Authorization&quot;, format!(&quot;Bearer {}&quot;, API_TOKEN).parse().unwrap());
	
	let resp = client.get(&quot;&lt;url&gt;&quot;)
								.headers(headers)
								.send()
								.await?;
	
	...
}
</code></pre><p>Here’s what we did above:</p><ul><li>We create a request client to send our request.</li><li>We create a mutable instance of the <code>HeaderMap</code> Instance that is similar to <code>HashMap</code></li><li>We insert our headers as key-value pairs to the header.<ul><li>Also, we use <code>.parse().unwrap()</code> on the <code>&amp;str</code> to convert the string type of the <em>header value</em> type.</li></ul></li><li>We then add our headers to the client request by using the <code>.headers()</code> method.</li><li>Also, one thing different from directly using the get method is that we have to call the <code>send</code> method on our request before awaiting on it.</li></ul><h3 id=sending-post-request-with-json-body>Sending post request with JSON body<a hidden class=anchor aria-hidden=true href=#sending-post-request-with-json-body>#</a></h3><p>We send the post request by using the <code>post</code> method on the <em>request client</em> or directly from the library and use the <code>json</code> method to add body to the post request.</p><p>The body here is just a <code>HashMap</code> in rust.</p><pre><code>...
let mut body = HashMap::new();
body.insert(&quot;username&quot;, &quot;myusername&quot;);
let resp = client.post(&quot;&lt;url&gt;&quot;)
	.json(&amp;body)
	.send()
	.await?;
...
</code></pre><h3 id=deserializing-the-json-response>Deserializing the JSON response<a hidden class=anchor aria-hidden=true href=#deserializing-the-json-response>#</a></h3><p>We can deserialize the JSON response from the API by using the <code>json</code> method on the sent request, and get that into our preferred shape or type by calling it generically with that type.</p><p>One thing to note is that the <strong>type must implement the Deserialize trait</strong>.</p><p>First thing first we create the type we want our JSON response in and implement the deserialize trait on it, implementing the trait ourselves is tedious and unreliable, so we use the <code>serde</code> library that we imported before to do that for us.</p><pre><code>use serde::Deserialize;

// deriving the Debug trait also to be able to print it
#[derive(Debug, Deserialize)]
struct APIResponse {
	message: String;
	error: String;
}
</code></pre><p>We can then use the above struct to deserialize our response as:</p><pre><code>...
let resp_json = resp.json::&lt;APIResponse&gt;().await?;
...
</code></pre><h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><ul><li><code>reqwest</code> <a href=https://docs.rs/reqwest>library documentation</a>,</li><li><a href=https://rust-lang.github.io/async-book>Rust Async documentation</a>,</li><li><a href=https://youtu.be/j9MsMYz9hBw>YouTube Tutorial by Tom</a>.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://celeroncoder.github.io/blog/tags/rest_api/>rest_api</a></li><li><a href=https://celeroncoder.github.io/blog/tags/guide/>guide</a></li><li><a href=https://celeroncoder.github.io/blog/tags/rust/>rust</a></li></ul><nav class=paginav><a class=prev href=https://celeroncoder.github.io/blog/posts/winston-transports/><span class=title>« Prev</span><br><span>Winston Transports??</span></a>
<a class=next href=https://celeroncoder.github.io/blog/posts/should-i-adopt-service-oriented-architecture-soa/><span class=title>Next »</span><br><span>Should I adopt Service Oriented Architecture (SOA)?</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://celeroncoder.github.io/blog>celeronCoder's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>