<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Functions in Memory (Stack) | celeronCoder's Blog</title><meta name=keywords content="memory,functions,stack,dsa"><meta name=description content="Explanation of how function behave in stack."><meta name=author content><link rel=canonical href=https://celeroncoder.github.io/blog/posts/functions-in-memory-stack/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raw.githubusercontent.com/gist/celeronCoder/bf4dbcc95f3919e2b374dc60b0c01391/raw/efe5fe3f1cfad1dd862fdbefd760f1815c6d2a1a/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://celeroncoder.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://celeroncoder.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://celeroncoder.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://celeroncoder.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Functions in Memory (Stack)"><meta property="og:description" content="Explanation of how function behave in stack."><meta property="og:type" content="article"><meta property="og:url" content="https://celeroncoder.github.io/blog/posts/functions-in-memory-stack/"><meta property="og:image" content="https://celeroncoder.github.io/blog/uploads/function_in_stack.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-18T18:30:00+00:00"><meta property="article:modified_time" content="2022-09-18T18:30:00+00:00"><meta property="og:site_name" content="celeronCoder"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://celeroncoder.github.io/blog/uploads/function_in_stack.webp"><meta name=twitter:title content="Functions in Memory (Stack)"><meta name=twitter:description content="Explanation of how function behave in stack."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://celeroncoder.github.io/blog/posts/"},{"@type":"ListItem","position":3,"name":"Functions in Memory (Stack)","item":"https://celeroncoder.github.io/blog/posts/functions-in-memory-stack/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Functions in Memory (Stack)","name":"Functions in Memory (Stack)","description":"Explanation of how function behave in stack.","keywords":["memory","functions","stack","dsa"],"articleBody":"Checkout my twitter thread explaining how functions work in memory (stack).\nThings to keep in mind to understand functions behavior\nWhen a function is called, it gets in the stack, and stays there until its execution. The function completes executions, it gets off the stack and returns to the program flow. Here’s a program with a main function that call some other functions and that function call some other function. As they get called, they are loaded into the memory stack.\nWhen the function, completes execution the functions gets off the stack and the program returns to the previous program flow, aka to the previous function that called that function. Now, there is nothing left in the stack, even the main function that is loaded by default, gets off the stack, the program finishes execution. Takeaways:\nWhen the function is called, it is loaded on the stack with its arguments. It completes execution, it gets off the stack, and the program returns to its previous program flow. If “A” function calls “B” function, “A” function will remain in the stack (and in scope also) until the “B” function returns. It means that not only the currently executing function remains in the function but also all the parent function that called it.\n","wordCount":"211","inLanguage":"en","image":"https://celeroncoder.github.io/blog/uploads/function_in_stack.webp","datePublished":"2022-09-18T18:30:00Z","dateModified":"2022-09-18T18:30:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://celeroncoder.github.io/blog/posts/functions-in-memory-stack/"},"publisher":{"@type":"Organization","name":"celeronCoder's Blog","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/gist/celeronCoder/bf4dbcc95f3919e2b374dc60b0c01391/raw/efe5fe3f1cfad1dd862fdbefd760f1815c6d2a1a/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://celeroncoder.github.io/blog accesskey=h title="celeronCoder's Blog (Alt + H)">celeronCoder's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://celeroncoder.github.io/blog>Home</a>&nbsp;»&nbsp;<a href=https://celeroncoder.github.io/blog/posts/>Posts</a></div><h1 class=post-title>Functions in Memory (Stack)</h1><div class=post-description>Explanation of how function behave in stack.</div><div class=post-meta><span title='2022-09-18 18:30:00 +0000 UTC'>September 18, 18030</span>&nbsp;·&nbsp;1 min</div></header><figure class=entry-cover><img loading=lazy src=https://celeroncoder.github.io/blog/uploads/function_in_stack.webp alt="blog cover"></figure><div class=post-content><p>Checkout my twitter <a href="https://twitter.com/CeleronCoder/status/1571901815616344065?s=20&t=LbPT98o7oYfORc-HDz63iA">thread </a>explaining how functions work in memory (stack).</p><p>Things to keep in mind to understand functions behavior</p><ul><li>When a function is called, it gets in the stack, and stays there until its execution.</li><li>The function completes executions, it gets off the stack and returns to the program flow.</li></ul><p>Here&rsquo;s a program with a main function that call some other functions and that function call some other function. As they get called, they are loaded into the memory stack.</p><p><img loading=lazy src=/blog/uploads/function_in_stack.webp alt></p><p>When the function, completes execution the functions gets off the stack and the program returns to the previous program flow, aka to the previous function that called that function.<img loading=lazy src=/blog/uploads/stack_get_off_1.webp alt>
<img loading=lazy src=/blog/uploads/stack_get_off_2.webp alt></p><p>Now, there is nothing left in the stack, even the main function that is loaded by default, gets off the stack, the program finishes execution.<img loading=lazy src=/blog/uploads/empty_stack_1.webp alt></p><p><strong>Takeaways:</strong></p><ul><li>When the function is called, it is loaded on the stack with its arguments.</li><li>It completes execution, it gets off the stack, and the program returns to its previous program flow.</li></ul><blockquote><p>If &ldquo;A&rdquo; function calls &ldquo;B&rdquo; function, &ldquo;A&rdquo; function will remain in the stack (and in scope also) until the &ldquo;B&rdquo; function returns. It means that not only the currently executing function remains in the function but also all the parent function that called it.</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://celeroncoder.github.io/blog/tags/memory/>memory</a></li><li><a href=https://celeroncoder.github.io/blog/tags/functions/>functions</a></li><li><a href=https://celeroncoder.github.io/blog/tags/stack/>stack</a></li><li><a href=https://celeroncoder.github.io/blog/tags/dsa/>dsa</a></li></ul><nav class=paginav><a class=next href=https://celeroncoder.github.io/blog/posts/italic-fonts/><span class=title>Next »</span><br><span>Italic Fonts</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://celeroncoder.github.io/blog>celeronCoder's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>