<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The type-safe guide to tRPC | celeronCoder's Blog</title><meta name=keywords content="nextjs,prisma,tRPC"><meta name=description content="tRPC is a typescript library, so to say, that makes it easy to create type-safe APIs without schema or any sort of code generation."><meta name=author content><link rel=canonical href=https://celeroncoder.github.io/blog/posts/the-type-safe-guide-to-trpc/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raw.githubusercontent.com/gist/celeronCoder/bf4dbcc95f3919e2b374dc60b0c01391/raw/efe5fe3f1cfad1dd862fdbefd760f1815c6d2a1a/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://celeroncoder.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://celeroncoder.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://celeroncoder.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://celeroncoder.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="The type-safe guide to tRPC"><meta property="og:description" content="tRPC is a typescript library, so to say, that makes it easy to create type-safe APIs without schema or any sort of code generation."><meta property="og:type" content="article"><meta property="og:url" content="https://celeroncoder.github.io/blog/posts/the-type-safe-guide-to-trpc/"><meta property="og:image" content="https://celeroncoder.github.io/uploads/trpcblog.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-27T18:30:00+00:00"><meta property="article:modified_time" content="2022-07-27T18:30:00+00:00"><meta property="og:site_name" content="celeronCoder"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://celeroncoder.github.io/uploads/trpcblog.png"><meta name=twitter:title content="The type-safe guide to tRPC"><meta name=twitter:description content="tRPC is a typescript library, so to say, that makes it easy to create type-safe APIs without schema or any sort of code generation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://celeroncoder.github.io/blog/posts/"},{"@type":"ListItem","position":3,"name":"The type-safe guide to tRPC","item":"https://celeroncoder.github.io/blog/posts/the-type-safe-guide-to-trpc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The type-safe guide to tRPC","name":"The type-safe guide to tRPC","description":"tRPC is a typescript library, so to say, that makes it easy to create type-safe APIs without schema or any sort of code generation.","keywords":["nextjs","prisma","tRPC"],"articleBody":"Check out the original article [here]().\nThis isn’t the best guide to use tRPC, probably there are better ways to do this, like [create-t3-app](https://create.t3.gg/), the best I could find.\nMost of what is here is from the [tRPC’s documentation](https://trpc.io/docs), you can refer them, super helpful and easy to read.\n*What is tRPC?*\ntRPC is a typescript library, so to say, that makes it easy to create type-safe APIs without schema or any sort of code generation.\n*Where to use?*\nCreate the typed server and then import its type and use it with an adaptor in the client side.\n*How does it implement type-safety?*\ntRPC encourages using the [zod](https://www.npmjs.com/package/zod), a library for type validation of input and output arguments.\n*Is tRPC only limited to React?*\ntRPC’s core API is built to work with any client, but right now it supports React and can be used with React Meta Frameworks like NextJS or SolidJS, since it uses React Query under the hood to talk to the server and maintaining type-safety across the data-pipeline or data-flow.\nFor now, it has first-party adaptors for React, NextJS, Express, Fastify, SolidJS, and some community packages like for [tRPC for SveleteKit](https://github.com/icflorescu/trpc-sveltekit)\n*What are its features?*\n- Lightweight, a tiny bundle size for such a powerful library.\n- Type-safe to the max!\n- Support subscriptions with websockets library.\n- Request batching\n- Request can be made simultaneously and then are batched into one. - Strong User base and helpful Community\n## tRPC x NextJS\nRecommended file structure:\n```tree\n.\n├── prisma # \u003c– if prisma is added\n│ └── [..]\n├── src\n│ ├── pages\n│ │ ├── _app.tsx # \u003c– add `withTRPC()`-HOC here\n│ │ ├── api\n│ │ │ └── trpc\n│ │ │ └── [trpc].ts # \u003c– tRPC HTTP handler\n│ │ └── [..]\n│ ├── server # \u003c– can be named backend or anything else\n│ │ ├── routers\n│ │ │ ├── app.ts # \u003c– main app router\n│ │ │ ├── post.ts # \u003c– sub routers\n│ │ │ └── [..]\n│ │ ├── context.ts # \u003c– create app context\n│ │ └── createRouter.ts # \u003c– router helper\n│ └── utils\n│ └── trpc.ts # \u003c– your typesafe tRPC hooks\n└── [..]\n```\n### Components\n*Router*\nThis is the router where the actual business logic will reside, create a `backend` folder inside the `src` directory and put all this stuff there.\nIf using prisma otherwise this is optional,\n`src/server/utils/prisma.ts`\n```ts\nimport { PrismaClient } from “@prisma/client”;\ndeclare global {\nvar prisma: PrismaClient | undefined; };\nexport const prisma = global.prisma || new PrismaClient({\nlog: \\[\"query\"\\] });\nif (process.env.NODE_ENV != ‘production’) global.prisma = prisma;\n```\n`src/server/router/context.ts`\n```ts\nimport * as trpc from “@trpc/server”;\nimport * as trpcNext from “@trpc/server/adapters/next”;\nimport { prisma } from “@/server/utils/prisma”; // this is optional\nexport const createContext = async (\noptions?: trpcNext.CreateNextContextOptions ) =\u003e {\nconst req = options?.req; const res = options?.res; return { req, res, prisma, // this is optional }; };\ntype Context = trpc.inferAsyncReturnType;\nexport const createRouter = () =\u003e trpc.router();\n```\nUsing Contexts\nWe can create router without using the above context by just using `trpc.router()` that will work just fine. But if you are using some external API like in the above case we are using prisma, it’s better to use pass in repeatedly used instances to context to avoid having multiple ones for every query we use that in, that may affect our performance and can also be vulnerable.\n`src/server/router/index.ts`\n```ts\nimport {createRouter} from “./contex”;\nimport {exampleRouter} from “./example.router”;\nexport const appRouter = createRouter()\n.merge(\"example.\", exampleRouter) .query(\"posts.count\", { async resolve({ctx}) { return await ctx.prisma.patient.count(); } }); export type AppRouter = typeof appRouter;\n```\n*API handler* aka NextJS adaptor:\nThe exact filename is necessary to make this work!\n`src/pages/api/trpc/[trpc].ts`\n```ts\nimport * as trpcNext from “@trpc/server/adapters/next”;\nimport { appRouter, AppRouter } from “@/backend/router”;\nimport { inferProcedureOutput } from “@trpc/server”;\nimport { createContext } from “@/backend/router/context”;\n// export API handler\nexport default trpcNext.createNextApiHandler({\nrouter: appRouter,\ncreateContext: createContext,\n});\n```\n*Hooks*\nThese are the React hooks necessary to maintain the type-safety, this will give you React Query like hooks to fetch the API.\n`src/utils/trpc.ts`\n```ts\nimport { createReactQueryHooks } from “@trpc/react”;\nimport type { AppRouter } from “@/backend/router”;\nimport { inferProcedureOutput } from “@trpc/server”;\nexport const trpc = createReactQueryHooks();\nexport type TQuery = keyof AppRouter[\"_def\"][“queries”];\n// helper type to infer query output\nexport type InferQueryOutput = inferProcedureOutput\u003c\nAppRouter[\"_def\"][“queries”][TRouteKey]\n;\n```\n*Example query in React Component*\nNow that tRPC is set up, this is how we use it inside react components.\n`src/pages/index.tsx`\n```tsx\n// we use the instance we created that has our router type definitions\nimport { trpc } from “@/utils/trpc”;\nexport default SomePage() {\nconst { isLoading, data:postsCount } = trpc.useQuery(\\[\"posts.count\"\\]); return ... }\n```\n### SSG Helpers\nSSG Helpers are helper functions that can be used to pre-fetch queries on the server upon request to reduce loading time.\nThey are to be used when working with SSR and SSG or ISR.\nHow to use it with `getServideSideProps` function of NextJS pages.\n```ts\n// /pages/posts/[id].tsx\nexport function getServerSideProps(\ncontext: GetServerSidePropsContext\u003c{id: string}\u003e ) {\nconst { id } = context.params; const ssg = createSSGHelpers({ router: appRouter, ctx: await createContext(), // { } if no context in your router transformer: superjson }); ssg.fetchQuery(\"posts.get\", {id}); return { props: { trpcState: ssg.dehydrate(), id } } }\nexport default function PostPage(props: InferGetServerSidePropsType) {\nconst {id} = props; // this query will be fetched instantly because of the cached // response of the query we fetching on server const {isLoading, data} = trpc.useQuery(\\[\"posts.get\"\\], {id}) return ... }\n```\n*References*\n- Check out [this](https://www.youtube.com/watch?v=I5tWWYBdlJo) amazing talk by [Theo](https://twitter.com/t3dotgg) on tRPC vs GraphQL and their risks.\n- Check out Theo on YouTube or any other social media platform, he has a lot of content about tRPC\n- Follow [Alex](https://twitter.com/alexdotjs) aka Katt, the creator of tRPC.\n","wordCount":"974","inLanguage":"en","image":"https://celeroncoder.github.io/uploads/trpcblog.png","datePublished":"2022-07-27T18:30:00Z","dateModified":"2022-07-27T18:30:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://celeroncoder.github.io/blog/posts/the-type-safe-guide-to-trpc/"},"publisher":{"@type":"Organization","name":"celeronCoder's Blog","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/gist/celeronCoder/bf4dbcc95f3919e2b374dc60b0c01391/raw/efe5fe3f1cfad1dd862fdbefd760f1815c6d2a1a/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://celeroncoder.github.io/blog accesskey=h title="celeronCoder's Blog (Alt + H)">celeronCoder's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://celeroncoder.github.io/blog>Home</a>&nbsp;»&nbsp;<a href=https://celeroncoder.github.io/blog/posts/>Posts</a></div><h1 class=post-title>The type-safe guide to tRPC</h1><div class=post-description>tRPC is a typescript library, so to say, that makes it easy to create type-safe APIs without schema or any sort of code generation.</div><div class=post-meta><span title='2022-07-27 18:30:00 +0000 UTC'>July 27, 27030</span>&nbsp;·&nbsp;5 min</div></header><figure class=entry-cover><img loading=lazy src=https://celeroncoder.github.io/uploads/trpcblog.png alt=trpcBlogCover></figure><div class=post-content><p>Check out the original article [here]().</p><p>This isn&rsquo;t the best guide to use tRPC, probably there are better ways to do this, like [create-t3-app](<a href=https://create.t3.gg/ title=https://create.t3.gg/>https://create.t3.gg/</a>), the best I could find.</p><p>Most of what is here is from the [tRPC&rsquo;s documentation](<a href=https://trpc.io/docs title=https://trpc.io/docs>https://trpc.io/docs</a>), you can refer them, super helpful and easy to read.</p><p>*<em>What is tRPC?</em>*</p><p>tRPC is a typescript library, so to say, that makes it easy to create type-safe APIs without schema or any sort of code generation.</p><p>*<em>Where to use?</em>*</p><p>Create the <em>typed server</em> and then import its type and use it with an adaptor in the client side.</p><p>*<em>How does it implement type-safety?</em>*</p><p>tRPC encourages using the [zod](<a href=https://www.npmjs.com/package/zod title=https://www.npmjs.com/package/zod>https://www.npmjs.com/package/zod</a>), a library for type validation of input and output arguments.</p><p>*<em>Is tRPC only limited to React?</em>*</p><p>tRPC&rsquo;s core API is built to work with any client, but right now it supports <strong>React</strong> and can be used with <strong>React Meta Frameworks</strong> like <strong>NextJS</strong> or <strong>SolidJS</strong>, since it uses <strong>React Query</strong> under the hood to talk to the server and maintaining type-safety across the data-pipeline or data-flow.</p><p>For now, it has first-party adaptors for <strong>React</strong>, <strong>NextJS</strong>, <strong>Express</strong>, <strong>Fastify</strong>, <strong>SolidJS</strong>, and some community packages like for [<strong>tRPC for SveleteKit</strong>](<a href=https://github.com/icflorescu/trpc-sveltekit title=https://github.com/icflorescu/trpc-sveltekit>https://github.com/icflorescu/trpc-sveltekit</a>)</p><p>*<em>What are its features?</em>*</p><p>- Lightweight, a tiny bundle size for such a powerful library.</p><p>- Type-safe to the max!</p><p>- Support subscriptions with <strong>websockets</strong> library.</p><p>- Request batching</p><pre><code>- Request can be made simultaneously and then are batched into one.
</code></pre><p>- Strong User base and helpful Community</p><p>## tRPC x NextJS</p><p>Recommended file structure:</p><p>```tree</p><p>.</p><p>├── prisma # &lt;&ndash; if prisma is added</p><p>│ └── [..]</p><p>├── src</p><p>│ ├── pages</p><p>│ │ ├── _app.tsx # &lt;&ndash; add `withTRPC()`-HOC here</p><p>│ │ ├── api</p><p>│ │ │ └── trpc</p><p>│ │ │ └── [trpc].ts # &lt;&ndash; tRPC HTTP handler</p><p>│ │ └── [..]</p><p>│ ├── server # &lt;&ndash; can be named backend or anything else</p><p>│ │ ├── routers</p><p>│ │ │ ├── app.ts # &lt;&ndash; main app router</p><p>│ │ │ ├── post.ts # &lt;&ndash; sub routers</p><p>│ │ │ └── [..]</p><p>│ │ ├── context.ts # &lt;&ndash; create app context</p><p>│ │ └── createRouter.ts # &lt;&ndash; router helper</p><p>│ └── utils</p><p>│ └── trpc.ts # &lt;&ndash; your typesafe tRPC hooks</p><p>└── [..]</p><p>```</p><p>### Components</p><p>*<em>Router</em>*</p><p>This is the router where the actual business logic will reside, create a `backend` folder inside the `src` directory and put all this stuff there.</p><p>If using prisma otherwise this is optional,</p><p>`src/server/utils/prisma.ts`</p><p>```ts</p><p>import { PrismaClient } from &ldquo;@prisma/client&rdquo;;</p><p>declare global {</p><pre><code>var prisma: PrismaClient | undefined;
</code></pre><p>};</p><p>export const prisma = global.prisma || new PrismaClient({</p><pre><code>log: \[&quot;query&quot;\]
</code></pre><p>});</p><p>if (process.env.NODE_ENV != &lsquo;production&rsquo;) global.prisma = prisma;</p><p>```</p><p>`src/server/router/context.ts`</p><p>```ts</p><p>import * as trpc from &ldquo;@trpc/server&rdquo;;</p><p>import * as trpcNext from &ldquo;@trpc/server/adapters/next&rdquo;;</p><p>import { prisma } from &ldquo;@/server/utils/prisma&rdquo;; // this is optional</p><p>export const createContext = async (</p><pre><code>options?: trpcNext.CreateNextContextOptions
</code></pre><p>) => {</p><pre><code>const req = options?.req;

const res = options?.res;



return {

	req,

	res,

	prisma, // this is optional

};
</code></pre><p>};</p><p>type Context = trpc.inferAsyncReturnType;</p><p>export const createRouter = () => trpc.router();</p><p>```</p><blockquote><p><strong>Using Contexts</strong></p></blockquote><blockquote></blockquote><blockquote><p>We can create router without using the above context by just using `trpc.router()` that will work just fine. But if you are using some external API like in the above case we are using prisma, it&rsquo;s better to use pass in repeatedly used instances to context to avoid having multiple ones for every query we use that in, that may <em>affect our performance and can also be vulnerable</em>.</p></blockquote><p>`src/server/router/index.ts`</p><p>```ts</p><p>import {createRouter} from &ldquo;./contex&rdquo;;</p><p>import {exampleRouter} from &ldquo;./example.router&rdquo;;</p><p>export const appRouter = createRouter()</p><pre><code>.merge(&quot;example.&quot;, exampleRouter)

.query(&quot;posts.count&quot;, {

	async resolve({ctx}) {

		return await ctx.prisma.patient.count();

	}

});
</code></pre><p>export type AppRouter = typeof appRouter;</p><p>```</p><p>*<em>API handler</em>* aka NextJS adaptor:</p><blockquote><p>The exact filename is necessary to make this work!</p></blockquote><p>`src/pages/api/trpc/[trpc].ts`</p><p>```ts</p><p>import * as trpcNext from &ldquo;@trpc/server/adapters/next&rdquo;;</p><p>import { appRouter, AppRouter } from &ldquo;@/backend/router&rdquo;;</p><p>import { inferProcedureOutput } from &ldquo;@trpc/server&rdquo;;</p><p>import { createContext } from &ldquo;@/backend/router/context&rdquo;;</p><p>// export API handler</p><p>export default trpcNext.createNextApiHandler({</p><p>router: appRouter,</p><p>createContext: createContext,</p><p>});</p><p>```</p><p>*<em>Hooks</em>*</p><p>These are the React hooks necessary to maintain the type-safety, this will give you React Query like hooks to fetch the API.</p><p>`src/utils/trpc.ts`</p><p>```ts</p><p>import { createReactQueryHooks } from &ldquo;@trpc/react&rdquo;;</p><p>import type { AppRouter } from &ldquo;@/backend/router&rdquo;;</p><p>import { inferProcedureOutput } from &ldquo;@trpc/server&rdquo;;</p><p>export const trpc = createReactQueryHooks();</p><p>export type TQuery = keyof AppRouter["_def"][&ldquo;queries&rdquo;];</p><p>// helper type to infer query output</p><p>export type InferQueryOutput = inferProcedureOutput&lt;</p><p>AppRouter["_def"][&ldquo;queries&rdquo;][TRouteKey]</p><blockquote><p>;</p></blockquote><p>```</p><p>*<em>Example query in React Component</em>*</p><p>Now that tRPC is set up, this is how we use it inside react components.</p><p>`src/pages/index.tsx`</p><p>```tsx</p><p>// we use the instance we created that has our router type definitions</p><p>import { trpc } from &ldquo;@/utils/trpc&rdquo;;</p><p>export default SomePage() {</p><pre><code>const { isLoading, data:postsCount } = trpc.useQuery(\[&quot;posts.count&quot;\]);

return &lt;div&gt;...&lt;/div&gt;
</code></pre><p>}</p><p>```</p><p>### SSG Helpers</p><p>SSG Helpers are helper functions that can be used to pre-fetch queries on the server upon request to reduce loading time.</p><p>They are to be used when working with SSR and SSG or ISR.</p><p>How to use it with `getServideSideProps` function of NextJS pages.</p><p>```ts</p><p>// /pages/posts/[id].tsx</p><p>export function getServerSideProps(</p><pre><code>context: GetServerSidePropsContext&lt;{id: string}&gt;
</code></pre><p>) {</p><pre><code>const { id } = context.params;

const ssg = createSSGHelpers({

	router: appRouter,

	ctx: await createContext(), // { } if no context in your router

	transformer: superjson

});

ssg.fetchQuery(&quot;posts.get&quot;, {id});

return {

	props: {

		trpcState: ssg.dehydrate(),

		id

	}

}
</code></pre><p>}</p><p>export default function PostPage(props: InferGetServerSidePropsType) {</p><pre><code>const {id} = props;

// this query will be fetched instantly because of the cached

// response of the query we fetching on server

const {isLoading, data} = trpc.useQuery(\[&quot;posts.get&quot;\], {id})

return ...
</code></pre><p>}</p><p>```</p><p>*<em>References</em>*</p><p>- Check out [this](<a href="https://www.youtube.com/watch?v=I5tWWYBdlJo" title="https://www.youtube.com/watch?v=I5tWWYBdlJo">https://www.youtube.com/watch?v=I5tWWYBdlJo</a>) amazing talk by [Theo](<a href=https://twitter.com/t3dotgg title=https://twitter.com/t3dotgg>https://twitter.com/t3dotgg</a>) on tRPC vs GraphQL and their risks.</p><p>- Check out Theo on YouTube or any other social media platform, he has a lot of content about tRPC</p><p>- Follow [Alex](<a href=https://twitter.com/alexdotjs title=https://twitter.com/alexdotjs>https://twitter.com/alexdotjs</a>) aka Katt, the creator of tRPC.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://celeroncoder.github.io/blog/tags/nextjs/>nextjs</a></li><li><a href=https://celeroncoder.github.io/blog/tags/prisma/>prisma</a></li><li><a href=https://celeroncoder.github.io/blog/tags/trpc/>tRPC</a></li></ul><nav class=paginav><a class=next href=https://celeroncoder.github.io/blog/posts/spinning-up-mysql-database-with-docker/><span class=title>Next »</span><br><span>Spinning up MySQL Database with Docker</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://celeroncoder.github.io/blog>celeronCoder's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>